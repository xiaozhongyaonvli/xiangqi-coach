# vibe coding 象棋指导棋
## v1.0.0 技术设计说明（Tech Spec）

> 目标：在 **不引入 AI / 引擎** 的前提下，实现一套 **规则正确、可测试、可扩展** 的中国象棋对战内核（engine-core）。
>
> 本文是给工程实现（含 Codex 托管开发）直接用的技术蓝图。

---

## 1. 设计原则

### 1.1 分层清晰
- **core（规则内核）**：纯逻辑、可测试、无 UI、无网络
- **app（应用层）**：CLI/HTTP/GUI 任一实现都可以依赖 core

v1.0.0 只保证 core 完整；app 可以先做最小交互（例如 CLI 或简单 HTTP），但不得污染 core。

### 1.2 单一事实来源（Single Source of Truth）
- 棋盘状态只存在于 `Position/Board` 对象中
- 走子只能通过 `Game.apply_move()` 发生（集中校验）

### 1.3 可扩展（为 v1.1+ 预留）
- 未来接入引擎：需要 **FEN/局面序列化**、**合法着法生成**
- 未来做分析：需要 **可回放 move history**、**可撤销/回滚**（可在 v1.0.0 先预留，不强制实现撤销）

---

## 2. 代码结构建议（Python）

推荐仓库结构（最小可行）：

xiangqi-coach/
src/
xiangqi_core/
init.py
types.py
coord.py
piece.py
board.py
move.py
rules.py
attack.py
legality.py
game.py
errors.py
app_cli/
main.py
tests/
test_coord.py
test_piece_moves.py
test_legality.py
test_checkmate.py
pyproject.toml
README.md
docs/
FSD_v1.0.0.md
TechSpec_v1.0.0.md

markdown
复制代码

说明：
- `xiangqi_core` 是核心库
- `app_cli` 只是 demo（可选）
- `tests/` 覆盖 core 行为

---

## 3. 核心数据模型

### 3.1 坐标系统（强制统一）

#### 3.1.1 内部坐标
- `x: 0..8`（列）
- `y: 0..9`（行）
- `y=0` 表示红方底线（红方视角）

#### 3.1.2 对外字符串坐标
- `a0..i9`
- 映射：`a->0, b->1, ... i->8`

#### 3.1.3 Coord 类型
- 使用不可变数据类（dataclass(frozen=True)）
- 提供：
  - `from_str("e2") -> Coord`
  - `to_str() -> "e2"`
  - `in_bounds()`

---

### 3.2 Piece（棋子）

```python
enum Side: RED, BLACK
enum PieceType: KING, ADVISOR, ELEPHANT, HORSE, ROOK, CANNON, PAWN

@dataclass(frozen=True)
class Piece:
    side: Side
    type: PieceType
注意：

piece 不包含位置（位置由 Board 维护），避免“双写不一致”

3.3 Move（走法）
python
复制代码
@dataclass(frozen=True)
class Move:
    frm: Coord
    to: Coord
v1.0.0 不做：

变体标记

记谱（中文/ICCS）输出

3.4 Board / Position（局面）
建议用 Position 表示完整局面（未来可拓展：轮到谁、历史等），v1.0.0 最小：

python
复制代码
class Position:
    board: Board
    side_to_move: Side
Board 内部用：

grid: list[list[Optional[Piece]]] 10x9
或

dict[Coord, Piece]（更易扩展/遍历）

推荐 v1.0.0 用 dict：

遍历更直观

生成攻击/着法更方便

复制局面更快（浅拷贝 dict）

4. 规则与校验模块
4.1 Rules（几何走法，不考虑“将军后合法性”）
文件：rules.py

职责：

给定 position、from、to

判断是否符合该棋子的几何走法 + 阻挡规则

不做“走后被将”的判断

接口建议：

python
复制代码
def is_pseudo_legal_move(pos: Position, move: Move) -> bool
伪合法（pseudo legal）= 走法形状合法 + 阻挡合法 + 目标格吃子规则合法（不能吃自己人）

4.2 Attack（攻击检测）
文件：attack.py

职责：

判断某一方是否攻击到某格（尤其是攻击到对方将）

给 is_in_check() 提供支持

接口建议：

python
复制代码
def is_square_attacked(pos: Position, by_side: Side, square: Coord) -> bool
def find_king(pos: Position, side: Side) -> Coord
def is_in_check(pos: Position, side: Side) -> bool
实现建议：

is_square_attacked 通过遍历 by_side 的所有棋子，测试它们是否存在伪合法攻击到 square 的路径

注意炮的吃子规则用于攻击判定（隔一子）

4.3 Legality（完全合法走法）
文件：legality.py

职责：

在伪合法基础上，加入：

轮到谁

走后己方不被将军

将帅对脸规则（可视为“走后被将/非法局面”）

接口建议：

python
复制代码
def is_legal_move(game: Game, move: Move) -> bool
def generate_legal_moves(pos: Position, side: Side) -> list[Move]
实现方式：

先检查 is_pseudo_legal_move

应用该 move 得到 pos2

检查 is_in_check(pos2, side) 为 False

检查“将帅对脸”（也可以融合进 is_in_check 逻辑里）

5. Game（对局管理）
文件：game.py

5.1 Game 状态
python
复制代码
class GameResult(Enum):
    ONGOING
    RED_WIN
    BLACK_WIN

class Game:
    position: Position
    history: list[Move]
    result: GameResult
5.2 apply_move（唯一入口）
python
复制代码
def apply_move(self, move: Move) -> None
流程：

若 result != ONGOING：拒绝

若 not is_legal_move(self, move)：抛异常 IllegalMoveError

执行落子（含吃子）

记录 history

切换 side_to_move

检查对方是否被将死：

如果 is_in_check(pos, opponent) 且 generate_legal_moves(pos, opponent) 为空 -> 本方胜

更新 result

6. 将死判定策略
判定将死（checkmate）最稳的方式：

对被将军一方生成所有合法走法

若 0 个，则将死

接口：

python
复制代码
def is_checkmate(pos: Position, side: Side) -> bool
注意：

v1.0.0 不强制实现“困毙（stalemate）”等额外规则（可作为 v1.0.1+）

但若出现无合法走法且不被将军，可先判负或判和——需要在 FSD 中明确；建议 v1.0.0 先 判和 或 不处理（最安全是判和，但中国象棋规则更复杂；MVP 可先记录为 “终局：无合法着法”）

7. 初始化标准开局
文件：board.py 或 game.py

提供：

python
复制代码
def initial_position() -> Position
必须符合标准中国象棋摆法：

红方在 y=0/1

黑方在 y=9/8

8. 错误与异常
文件：errors.py

IllegalMoveError(message, move)

GameOverError(message)

ParseCoordError

ParseMoveError

原则：

core 抛异常

app 层捕获并提示用户

9. 测试策略（v1.0.0 必做）
9.1 单元测试（核心）
Coord 解析与边界

每个棋子的伪合法走法：

车直线阻挡

炮隔子吃子

马腿、象眼

兵过河前后

is_in_check 基本局面

将帅对脸

简单将死局面（2~3 个固定例子）

9.2 规则回归测试
随机走若干步（从合法着法集中抽样）应不崩溃

每步 apply_move 后，局面仍可序列化/复制（若实现）

10. App（最小演示层，可选）
10.1 CLI 需求（可选但推荐）
输入：e2e3（from-to）

输出：当前棋盘 ASCII

显示：轮到谁、是否将军、是否结束

注意：CLI 只是演示，不影响 core 交付。

11. v1.0.0 Definition of Done（工程角度）
✅ xiangqi_core 可被 import

✅ Game.apply_move() 能跑完整对局（人工输入）

✅ tests/ 全绿

✅ core 不依赖 UI，不依赖网络，不依赖 LLM

✅ 代码结构为后续 v1.1 引擎接入预留扩展点（Position/Move/History）
```